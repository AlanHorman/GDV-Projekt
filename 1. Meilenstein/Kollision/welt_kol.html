<html>
    <head>
        <title>Nimmersatts Welt</title>
    </head>

    <body>
        <script src="..\..\Application\page\extern\three_js\build\three.min.js">
        </script>
        <script src="..\..\Application\page\extern\three_x\threex.keyboardstate.js">
        </script>

        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var geometry1 = new THREE.PlaneGeometry(14, 14);
            var material1 = new THREE.MeshBasicMaterial({color: 0x339900, side: THREE.DoubleSide});
            var meadow = new THREE.Mesh(geometry1, material1);

            var geometry2 = new THREE.PlaneGeometry(12, 12);
            var material2 = new THREE.MeshBasicMaterial({color: 0xCC9900, side: THREE.DoubleSide});
            var soil = new THREE.Mesh(geometry2, material2);

            var geometry3 = new THREE.CubeGeometry(1, 1, 1, 1, 1, 1); // für die Kollision 
            var material3 = new THREE.MeshBasicMaterial({color: 0x00ff00});
            var cube = new THREE.Mesh(geometry3, material3);


            //Kollisionen
            var collisionList = [];
            var wandaufbau = new THREE.CubeGeometry(1, 1, 15);
            var wandMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
            var wand_links = new THREE.Mesh(wandaufbau, wandMaterial);


            collisionList.push(wand_links);

            scene.add(meadow);
            scene.add(soil);
            scene.add(cube);

            //Kollisionen hinzufügen
            scene.add(wand_links);
            wand_links.position.x = -7.5;

            //Kollision ende 


            soil.rotation.x = -1.57;
            soil.position.y = 0.10;
            meadow.rotation.x = -1.57;
            camera.rotation.x = -0.78;
            camera.position.y = 10;
            camera.position.z = 10;


            var render = function () {
                requestAnimationFrame(render);
                renderer.render(scene, camera);
                update();
            };

            /*
             * 
             function moveCube(event)
             {
             if (event.keyCode == 37)
             {
             cube.position.x -= 0.1;
             }
                     
             if (event.keyCode == 38)
             {
             cube.position.z -= 0.1;
             }
                     
             if (event.keyCode == 39)
             {
             cube.position.x += 0.1;
             }
                     
             if (event.keyCode == 40)
             {
             cube.position.z += 0.1;
             }
                     
                     
             }
             */

       

            function update()
            {

                var originPoint = cube.position.clone();
            
                

                for (var vertexIndex = 0; vertexIndex < cube.geometry.vertices.length; vertexIndex++)
                {
                    var localVertex = cube.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(cube.matrix);
                    var directionVector = globalVertex.sub(cube.position);

                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                    var collisionResults = ray.intersectObjects(collisionList);
                    if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length())
                    {
                       
                        console.log("Es wurde getroffen!");
                    }
                    
                    
                }

              
           
            }
            //Testfunktion - kann später gelöscht werden 

     function animate() {


                requestAnimationFrame(animate);

                //mesh.rotation.x += 0.05;
                //mesh.rotation.y += 0.01;
                //  mesh.translationZ(10);
                // mesh.position.z = zTranslation; 
                //.loop für wiederholung 
                cube.translateX(-0.1); //Testfunktion bewegt den cube 



            }




            //window.addEventListener('keypress', animate);
            //render();

            render()
            {
                    animate();
                    //update();
                };
        </script>
    </body>
</html>